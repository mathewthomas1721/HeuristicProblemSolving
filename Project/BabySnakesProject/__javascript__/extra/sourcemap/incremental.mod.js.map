{
	"version": 3,
	"file": "/Users/mathewthomas/HeuristicProblemSolving/Project/BabySnakesProject/__javascript__/incremental.mod.js",
	"sources": [
		"/Users/mathewthomas/HeuristicProblemSolving/Project/BabySnakesProject/incremental.py"
	],
	"sourcesContent": [
		"#2017 Paul Fisher, Mathew Thomas : The Baby Snakes\n\n#This is the standard cost increase multiplier for a single player game. Increase/decrease this to make game harder/easier\nbase_mult = 1.25\n\n#This is the standard cost increase multiplier for a two player game. Increase/decrease this to tilt the balance of the game towards the adversary/player\nbase_pen = 1.5\n\n#Put currency amounts in desired format. Amounts and costs are stored as floating point numbers, but we want to\n#   display them as integers. For costs, we always round up, so that the property is always able to be purchased when\n#   it appears that the player has enough currency. For values larger than 1,000,000, we display in scientific notation\n#Params:\n#   num : floating point number to put in proper format\n# return: number in proper format (a String)\ndef toForm(num):\n    if (num > 1000000): # cutoff for displaying in exponential form\n        return num.toExponential(3) #Represent as exponential with 3 decimal placed\n    else:\n        round_num = num.toFixed(0)\n        if int(round_num) < num:   #If toFixed has rounded down, add 1\n            return (num + 1).toFixed(0)\n        else:\n            return round_num\n\n#Put currency amounts in desired format. Amounts and costs are stored as floating point numbers, but we want to\n#   display them as integers.  This function uses standard rounding. For values larger than 1,000,000, we display in scientific notation.\n#Params:\n#   num : floating point number to put in proper format\n# return: number in proper format (a String)\ndef toForm2(num):\n    if (num > 1000000):\n        return num.toExponential(3)\n    else:\n        return num.toFixed(0)\n\n\n#Return a singular or plural 'KitKat', depending on the amount\n#Params:\n#   n : amount of KitKats\ndef currencyName(n):\n    if n == 1: # if the amount is 1, return the singular form\n        return 'KitKat'\n    else: #otherwise return the plural\n        return 'KitKats'\n\n#Class storing information for a property in the incremental game. In our case, a particular game or problem\nclass Property:\n    #Create a new Property\n    #Params:\n    #   name : name of the property (e.g. \"Burger Stand\")\n    #   base_cost : original cost to buy an instance of this property\n    #   cost_mult : The factor by which the cost increases on each purchase in single player\n    #   base_income : income of one of these properties, before any upgrades\n    def __init__(self,name, base_cost, cost_mult, base_income):\n        self.name = name\n        self.cost = base_cost\n        self.mult = cost_mult\n        self.income = base_income\n        self.count = 0.0    #number of this property owned\n        self.total_income = 0.0;  #total income earned by all copies of this property\n        self.upgrades_Available = []\n\n    #return income per seond of one intstance of the property\n    def get_income(self):\n        return self.income\n\n\n    #increase the cost of this property by its cost multiplier\n    def inc_cost(self):\n        self.cost *= self.mult\n\n    #Increase the number of this property owned.\n    def buy(self):\n        self.count += 1\n        self.total_income = self.count * self.income #total income is updated. count * income.\n\n    #return the nexr available upgrade to this property\n    def get_next_upgrade(self):\n        return self.upgrades_Available[0]\n\n    #Apply next upgrade to this property\n    def upgrade(self):\n        ug = self.upgrades_Available[0]\n        self.income *= ug.mult #Upgrding will multiply the income by some factor\n        if len(self.upgrades_Available) == 1: #If this is the last upgrade in the series, we keep it and increase its cost by a factor of 10\n            ug.cost *= 10\n        else:\n            self.upgrades_Available.pop(0) # Otherwise we remove this upgrade as it could only be used once\n        self.total_income = self.count * self.income\n\n#Class containing information for an upgrade\nclass Upgrade:\n    #Create a new upgrade\n    #Params:\n    #   name : name of this upgrade (this isn't visible to the user in this version)\n    #   cost : base cost to purchase this upgrade\n    #   mult : factor by which to multiply production of its property\n    def __init__(self, name, cost, mult):\n        self.name = name\n        self.cost = cost\n        self.mult = mult\n\n#Class containing information for a penalty\nclass Penalty:\n    #Create a new Penalty\n    #Params:\n    #   pen : a tuple containing name and other information for the penalty.\n    #       in this game it is of the form (name, type, prop, mult)\n    #       name : name of the penalty, string. Not visible in current version\n    #       type : We implemented other types of penalties, but only the cost-increase made it into the final game, an int\n    #       prop : The property being penalize, an int\n    #       mult : the multiplier by which to increase cost of the property\n    def __init__(self,pen):\n        self.name = pen[0]\n        if pen[1] == 0: #this allows the addition of other types of penalties in the future\n            self.type = 0\n            self.prop = pen[2]\n            self.mult = pen[3]\n\n\n\n#Class for an instance of a game. This class is instantiated in a single player game\nclass Game:\n    #Setup game data\n    #Params:\n    #   props: A list of tuples containing info for the properties to be available in this game\n    #           (name, base_cost, cost_mult, base_income) as specified above\n    #   upgrades: A list of tuples containing info for the upgrades to be available\n    #           (name, prop, cost, mult)\n    #           prop : index of property being upgraded. Other fields are as defined above\n    def __init__(self, props, upgrades):\n        self.counter = 0 #counter for adversary's time-based earning of penalties\n        self.time = 0   #time elapse in game in seconds\n        self.currency = 6.0 #Initial currency for the player\n        self.cum_currency = 0.0 #Gross currency earned by the player in this game\n        self.pen_count = 0 #Number of penalties available to the adversary (if two player game)\n        self.properties = []\n        self.global_multiplier = 1.0 # not used in this version. Kept for possible use in new upgrades/penalties\n        for prop in props:  #Add a property to this game for each tuple in the props list\n            self.properties.append(Property(prop[0], prop[1], prop[2], prop[3]))\n        for ug in upgrades: #Create each upgrade and add it to the appropriate property's list of upgrades\n            self.properties[ug[1]].upgrades_Available.append(Upgrade(ug[0], ug[2], ug[3]))\n\n    #Buy a property if the player has sufficient funds\n    #Params:\n    #   prop_to_buy : index of property the player wants to buy\n    #return : True on success, False on failure\n    def buy_prop(self, prop_to_buy):\n        prop = self.properties[prop_to_buy]\n        if self.currency >= prop.cost: # Only buy if the player has enough currency to pay the cost\n            self.currency -= prop.cost\n            prop.inc_cost()            #property cost increases on buy\n            prop.buy()                 #Actually increment the number of the property owned\n            return True\n        return False\n\n\n    #Upgrade a property with the next available upgrade\n    #Params:\n    #   prop_to_upgrade : index of property being upgrades\n    #return : True on success, False on failure\n    def upgrade_prop(self, prop_to_upgrade):\n        prop = self.properties[prop_to_upgrade] # get property object\n        ug = prop.upgrades_Available[0] #get upgrade from property's list\n        if self.currency >= ug.cost: #Check if player can afford\n            self.currency -= ug.cost\n            prop.upgrade()\n            return True\n        return False\n\n    #One game cycle. Called every second.\n    def cycle(self):\n        self.counter += 1 #one timestep\n        self.time += 1\n        for prop in self.properties: #Player receives income from all properties\n            self.currency += prop.total_income * self.global_multiplier\n            self.cum_currency += prop.total_income * self.global_multiplier\n\n#Class for an instance of a two player game. Inherits from Game\nclass Two_Player_Game(Game):\n    #Start a new two player game\n    #Params:\n    #   props: A list of tuples containing info for the properties to be available in this game\n    #           (name, base_cost, cost_mult, base_income) as specified above\n    #   upgrades: A list of tuples containing info for the upgrades to be available\n    #           (name, prop, cost, mult)\n    #           prop : index of property being upgraded. Other fields are as defined above\n    #   penalties : A list of tuples containung info for penalties available to the adversary. Format as above\n    def __init__(self, props, upgrades, penalties):\n        Game.__init__(self, props, upgrades) #Call superclass constructor\n        self.penalties = []\n        self.active_penalties = []\n        for pen in penalties: #Create each penalty object and add to list\n            self.penalties.append(Penalty(pen))\n        #Because in a two player game, the costs only increase through penalties\n        for prop in self.properties:\n            prop.mult = 1.0     #change all the property's cost_increas multipliers from their default value to 1.0\n\n\n    #Buy a property if the player has sufficient funds\n    #Params:\n    #   prop_to_buy : index of property the player wants to buy\n    def buy_prop(self, prop_to_buy):\n        succeed = Game.buy_prop(self, prop_to_buy) #Superclass buy\n        if succeed: #If the purchase goes through,\n            self.counter = 0.  #Reset counter for next penalty\n            self.pen_count += 1.    #and increment the number of penalties the adversary has.\n\n    #One game cycle. Called every second.\n    def cycle(self):\n        Game.cycle(self)\n        if self.counter >= 20: #If player has gone 20 seconds without a purchase,\n            self.pen_count += 1 #give the adversary another penalty\n            self.counter = 0\n        #This is code for penalties that had a duration. Not used in final version.\n        #new_active = self.active_penalties\n        #self.active_penalties = []\n        #for pen in new_active:\n        #    pen.time_left -= 1\n        #    if pen.time_left == 0:\n        #        self.global_multiplier *= (1.0 / pen.mult)\n        #        pen.time_left = pen.duration\n        #    else:\n        #        self.active_penalties.append(pen)\n\n    #Apply a penalty to a property\n    #Params:\n    #   pen_no : The index of the penalty to apply\n    def applyPenalty(self, pen_no):\n        if self.pen_count > 0:  #only apply penlaty if the adversary has one available\n            self.pen_count -= 1\n            pen = self.penalties[pen_no] #get penalty object\n            if pen.type == 0:\n                self.properties[pen.prop].cost *= pen.mult #apply cost increase multiplier\n            #used for penalties witha duration that affected global multiplier. Not used in final version\n            #elif pen.type == 1: #used for\n            #    self.active_penalties.append(pen)\n            #    self.global_multiplier *= pen.mult\n\n\n#Top level Class for running gamde and interacting with HTML\nclass incremental:\n    #List of tuples for constructing the properties\n    #Format: (name, base_cost, cost_mult, base_income)\n    #Change names to change the theme of the game\n    #Base costs and incomes can be tweaked to change the balance and progression of the game.\n    properties = [list (tupl) for tupl in [\n        ('Expanding Nim', 6.0, base_mult, 1.0),\n        ('Stoplight Shortest Path', 50.0, base_mult, 6.0),\n        ('No Tipping', 400.0, base_mult, 35.0),\n        ('Gravitational Voronoi', 2000.0, base_mult, 144.0),\n        ('Evasion',  10000.0, base_mult, 600.0),\n        ('Dancing Without Stars',  50000.0, base_mult, 2200.0),\n        ('Compatibility Game',  400000.0, base_mult, 11111.0),\n        ('Auction Game',  2000000.0, base_mult, 40000.0)\n    ]]\n\n    #List of tuples for constructing the upgrades\n    #Format : (name, property, base cost, multiplier)\n    #The names are not currently used\n    #base costs and multipliers can be tweaked to change the balance and progression of the game\n    upgrades = [list (tupl) for tupl in [\n        ('Dynamic Programming', 0, 40, 2.0),\n        (\"Dijkstra's Algorithm\", 1, 250, 2.0),\n        ('Dynamic Programming', 2, 3000, 2.0),\n        ('Clustering', 3, 18000, 2.0),\n        ('No Diagonal Walls', 4, 80000, 2.0),\n        ('Simulated Annealing', 5, 500000, 2.0),\n        ('Depth First Search', 6, 7000000, 2.0),\n        ('Block Opponents', 7, 33000000, 2.0),\n    ]]\n\n    #List of tuples for constructing the penalties\n    #Format: (name, type, property, cost_mult)\n    #Names not currently used\n    #All penalties in this game are type 0: cost multipliers\n    penalties = [list (tupl) for tupl in [\n        ('Cost Increase 1', 0, 0, base_pen),\n        ('Cost Increase 2', 0, 1, base_pen),\n        ('Cost Increase 3', 0, 2, base_pen),\n        ('Cost Increase 4', 0, 3, base_pen),\n        ('Cost Increase 5', 0, 4, base_pen),\n        ('Cost Increase 6', 0, 5, base_pen),\n        ('Cost Increase 7', 0, 6, base_pen),\n        ('Cost Increase 8', 0, 7, base_pen),\n    ]]\n\n    #Default ending time for \"infinite\" game\n    def __init__ (self):\n        self.endtime = 100000000\n\n\n\n    #Initialize a one player game. Function called on click of Single Player Game Button\n    def StartOnePlayer(self):\n\n        self.gm = Game(self.properties, self.upgrades) #set game to a new one playter game\n        self.two_player = False\n        self.Setup()\n\n    #Initialize a two player game. Function called on click of Two Player Game Button\n    def StartTwoPlayer(self):\n\n        self.gm = Two_Player_Game(self.properties,self.upgrades, self.penalties) #set game to a new two playter game\n\n        #Add event listener to map 1 - 8 keys to the penalty buttons\n        window.addEventListener('keydown', self.respondKey)\n        #These sections are only needed in a two player game, so make these visible here\n        document.getElementById(\"ins\").style.display = \"inline-block\"\n        document.getElementById(\"adPane\").style.display = \"inline-block\"\n\n        self.two_player = True\n        self.Setup()\n\n\n    #End a game after time has expired\n    def EndGame(self):\n\n        #Make game playing sections invisible\n        document.getElementById(\"adPane\").style.display = \"none\"\n        document.getElementById(\"cash\").style.display = \"none\"\n        document.getElementById(\"ins\").style.display = \"none\"\n        for n in [1,2,3,4,5,6,7,8]:\n            document.getElementById(\"sec\" + str(n)).style.display = \"none\"\n\n        #Make the home screen buttons and result text visible\n        document.getElementById(\"startButtons\").style.display = \"inline-block\"\n        document.getElementById(\"resDiv\").style.display = \"inline-block\"\n\n        #Set results text\n        document.getElementById(\"resDiv\").innerHTML = \"Game Over. Player earned {} KitKats in {} seconds.\".format(toForm2(self.gm.cum_currency), self.endtime)\n\n        #Remove update function and key listener\n        window.clearInterval(self.inter)\n        window.removeEventListener('keydown', self.respondKey)\n\n    #Called on property buy button press. Attempt to buy a property.\n    #Params:\n    #   n : 1-based index of property to buy\n    def BuyProp(self, n):\n\n        self.gm.buy_prop(n - 1)  #Attempt to buy the property\n        prop = self.gm.properties[n-1]  #get property object\n\n        #Update property text with new count and cost of property\n        document.getElementById ('prop'+ str(n)) .innerHTML = \"You've developed {} {} algorithms. <br>Earning {} {} per second.\".format (prop.count, prop.name, toForm2(prop.total_income), currencyName(prop.total_income))\n        document.getElementById ('PC'+ str(n)) .innerHTML = 'Cost: {} KitKats'.format (toForm(prop.cost))\n\n        #Since player may have spent currency, update text that tracks current currency\n        if (self.endtime - self.gm.time < 10000): #only display timer if there are less than 10000 seconds Remaining\n            document.getElementById('cash').innerHTML = 'Total KitKats: {}<br>Remaining Time : {}'.format(toForm2(self.gm.currency), self.endtime - self.gm.time)\n        else:\n            document.getElementById('cash').innerHTML = 'Total KitKats: {}'.format(toForm2(self.gm.currency))\n\n        #A sucessful purchase adds a penalty in two player, so update that text\n        if self.two_player:\n            document.getElementById ('advcount') .innerHTML = 'Available Penalties : {}'.format(self.gm.pen_count)\n\n\n    #Called on property upgrade button press. Attempt to upgrade a property.\n    #Params:\n    #   n : 1-based index of property to upgrade\n    def UpgradeProp(self, n):\n\n        self.gm.upgrade_prop(n - 1) # attempt to upgrade the property\n\n        prop = self.gm.properties[n-1] #get property object\n\n        #Since player may have spent currency, update text that tracks current currency\n        if (self.endtime - self.gm.time < 10000):   #only display timer if there are less than 10000 seconds Remaining\n            document.getElementById('cash').innerHTML = 'Total KitKats: {}<br>Remaining Time : {}'.format(toForm2(self.gm.currency), self.endtime - self.gm.time)\n        else:\n            document.getElementById('cash').innerHTML = 'Total KitKats: {}'.format(toForm2(self.gm.currency))\n        document.getElementById ('prop'+ str(n)) .innerHTML = \"You've developed {} {} algorithms. <br>Earning {} {} per second.\".format (prop.count, prop.name, toForm2(prop.total_income), currencyName(prop.total_income))\n\n        #Update tooltip giving per-property income info\n        document.getElementById('tt' + str(n)).innerHTML = \"Each {} algorithm earns {} {} per second\".format(prop.name, toForm2(prop.income), currencyName(prop.income))\n\n        ug = prop.get_next_upgrade() #get upgrade object\n\n        #Update tootip with new upgrade, and update upgrade cost text\n        document.getElementById('ttu' + str(n)).innerHTML = 'Multipy all {} earnings by {}'.format(prop.name, ug.mult)\n        document.getElementById('UC' + str(n)).innerHTML = 'Upgrade : {} KitKats'.format(toForm(ug.cost))\n\n\n    #Called on penalty button press or key press. Attempt to penalize a property.\n    #Params:\n    #   n : 1-based index of penalty to use\n    def ApplyPenalty(self, n):\n        self.gm.applyPenalty(n - 1) #attempt to apply the penalty\n\n        #Update available penalties text\n        document.getElementById ('advcount') .innerHTML = 'Available Penalties : {}'.format(self.gm.pen_count)\n\n        prop = self.gm.properties[n-1]\n\n        #update property cost and penalty tooltip\n        document.getElementById ('PC'+ str(n)) .innerHTML = 'Cost: {} KitKats'.format (toForm(prop.cost))\n        document.getElementById ('tta'+str(n)) .innerHTML = 'Increase cost of {} by a factor of {}'.format(prop.name, self.gm.penalties[n].mult.toFixed(2))\n\n    #Respond to a keypress\n    #On press of \"1\" to \"8\" keys, call penalty function with appropriate parameter. Otherwise dop nothing\n    def respondKey(self, event):\n        self.keyCode = event.keyCode\n        if self.keyCode == ord ('1'):\n            self.ApplyPenalty(1)\n        elif self.keyCode == ord ('2'):\n            self.ApplyPenalty(2)\n        elif self.keyCode == ord ('3'):\n            self.ApplyPenalty(3)\n        elif self.keyCode == ord ('4'):\n            self.ApplyPenalty(4)\n        elif self.keyCode == ord ('5'):\n            self.ApplyPenalty(5)\n        elif self.keyCode == ord ('6'):\n            self.ApplyPenalty(6)\n        elif self.keyCode == ord ('7'):\n            self.ApplyPenalty(7)\n        elif self.keyCode == ord ('8'):\n            self.ApplyPenalty(8)\n\n    #Called every second through window.setInterval\n    def Update (self):\n        self.gm.cycle() #Call one game cycle\n\n        #Update currency display, since income is earned every cycle\n        if (self.endtime - self.gm.time < 10000):\n            document.getElementById('cash').innerHTML = 'Total KitKats: {}<br>Remaining Time : {}'.format(toForm2(self.gm.currency), self.endtime - self.gm.time)\n        else:\n            document.getElementById('cash').innerHTML = 'Total KitKats: {}'.format(toForm2(self.gm.currency))\n\n        #Update penalty count text sin two player game, since that may have changed\n        if self.two_player:\n            document.getElementById ('advcount') .innerHTML = 'Available Penalties : {}'.format(self.gm.pen_count)\n\n        #Check if time has expired\n        if self.gm.time >= self.endtime:\n            self.EndGame()\n\n\n    #Contains code to setup the screen for a new game\n    def Setup(self):\n\n        #Get number from the text box an the start screen\n        textbox = document.getElementById(\"timeSet\")\n        #Use to set the ending time of the game\n        self.endtime = int(textbox.elements[0].value)\n        if self.endtime == 0:\n            self.endtime = 1000000000\n\n        #Make start screen sections invisible\n        document.getElementById(\"startButtons\").style.display = \"none\"\n        document.getElementById(\"resDiv\").style.display = \"none\"\n        document.getElementById(\"story\").style.display = \"none\"\n\n        #Show currency display and property sections\n        document.getElementById(\"cash\").style.display = \"inline-block\"\n        for n in [1,2,3,4,5,6,7,8]:\n            document.getElementById(\"sec\" + str(n)).style.display = \"inline-block\"\n\n        #initialize currency display\n        if (self.endtime - self.gm.time < 10000):\n            document.getElementById('cash').innerHTML = 'Total KitKats: {}<br>Remaining Time : {}'.format(toForm2(self.gm.currency), self.endtime - self.gm.time)\n        else:\n            document.getElementById('cash').innerHTML = 'Total KitKats: {}'.format(toForm2(self.gm.currency))\n\n\n        # In two player game, initialize adversary count text\n        if self.two_player:\n            document.getElementById ('advcount') .innerHTML = 'Available Penalties : {}'.format(self.gm.pen_count)\n\n        for n in [1,2,3,4,5,6,7,8]:  #for each property\n            prop = self.gm.properties[n-1] #get property object\n            #Initialize penalty areas tooltips\n            if self.two_player:\n                document.getElementById ('tta'+str(n)) .innerHTML = 'Increase cost of {} by a factor of {}'.format(prop.name, self.gm.penalties[n-1].mult.toFixed(2))\n\n            #Initialize all property, upgrade, cost, and tooltip text\n            document.getElementById ('prop'+ str(n)) .innerHTML = \"You've developed {} {} algorithms. <br>Earning {} {} per second.\".format (prop.count, prop.name, toForm2(prop.total_income), currencyName(prop.total_income))\n            document.getElementById ('PC'+ str(n)) .innerHTML = 'Cost: {} KitKats'.format (toForm(prop.cost))\n            document.getElementById('tt' + str(n)).innerHTML = \"Each {} algorithm earns {} {} per second\".format(prop.name, toForm2(prop.income), currencyName(prop.income))\n            ug = prop.get_next_upgrade() #Get upgrade object\n            document.getElementById('ttu' + str(n)).innerHTML = 'Multipy all {} earnings by {}'.format(prop.name, ug.mult)\n            document.getElementById('UC' + str(n)).innerHTML = 'Upgrade : {} KitKats'.format(toForm(ug.cost))\n\n        #Set the Update() function to run once per second.\n        self.inter = window.setInterval(self.Update, 1000)\n\n\n\ngame = incremental ()\n"
	],
	"mappings": "AAAA;AAGA;AAGA;AAQA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAMA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAGA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAIA;AAAA;AAAA;AAIA;AAAA;AAEA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AAGA;AAMA;AACA;AACA;AACA;AAAA;AAAA;AAGA;AASA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAKA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAMA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAOA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AASA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAMA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAAA;AAEA;AAAA;AAAA;AAeA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAKA;AAAA;AAQA;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAQA;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAQA;AARA;AAAA;AAAA;AAAA;AAYA;AACA;AAAA;AAKA;AAEA;AACA;AACA;AAAA;AAGA;AAEA;AAGA;AAEA;AACA;AAEA;AACA;AAAA;AAIA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AAGA;AAGA;AACA;AAAA;AAKA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AAMA;AAEA;AAEA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAGA;AAEA;AAGA;AACA;AAAA;AAMA;AACA;AAGA;AAEA;AAGA;AACA;AAAA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAGA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AAGA;AACA;AAAA;AAAA;AAIA;AAGA;AAEA;AACA;AACA;AAAA;AAGA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAIA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA"
}